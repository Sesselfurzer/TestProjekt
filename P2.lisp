(defun simp(expr)
  (if (atom expr)
    expr
    (let ((args (mapcar #'simp (cdr expr))))
      (cond
        ((equal (car expr) '+)
          (setq args (remove 0 args))
          (case (length args)
            (0 0)
            (1 (car args))
            (otherwise (cons '+ args)) ))
        ((equal (car expr) '*)
          (if (member 0 args)
              0
              (progn
                (setq args (remove 1 args))
                (case (length args)
                  (0 1)
                  (1 (car args))
                  (otherwise (cons '* args))))))
        ((equal (car expr) '-)
         (setq args (cons (car args) (remove 0 (cdr args))))
         (case (length args)
               (0 0)
               (1 (car args))
               (otherwise (cons '- args))))
        ((equal (car expr) '/)
         (if (member 0 args)
             0
             (case (length args)
                (0 1)
                (1 (car args))
                (otherwise (cons '/ args)))))
        ((equal (car expr) 'sin)
         (if (member 0 args)
             0
             (cons 'sin args)))
        ((equal (car expr) 'cos)
         (if (member 0 args)
             1
             (cons 'cos args)))
        ((equal (car expr) 'tan)
         (if (member 0 args)
             0
             (cons 'tan args)))
        ((equal (car expr) 'exp)
         (if (member 0 args)
             1
             (cons 'exp args)))
        (T (cons (car expr) args))))))


(defun deriv (expr var)
  "Compute the derivative of expr using var"
  (cond ((constantp expr)
         0)
        ((atom expr)
         (if (equal expr var) 1 0))
        ;;; (u + v)' = u' + v'
        ((equal (car expr) '+)
         (list '+ (deriv (cadr expr) var) (deriv (caddr expr) var)))
        ;;; (u - v)' = u' - v'
        ((equal (car expr) '-)
         (list '- (deriv (cadr expr) var) (deriv (caddr expr) var)))
        ;;; (u * v)' = u' * v + u * v'
        ((equal (car expr) '*)
         (list '+ (list '* (deriv (cadr expr) var) (caddr expr))
                  (list '* (cadr expr) (deriv (caddr expr) var))))
        ;;; (u / v)' = (u' * v - u * v') / (v * v)
        ((equal (car expr) '/)
         (list '/ (list '- (list '* (deriv (cadr expr) var) (caddr expr))
                           (list '* (cadr expr) (deriv (caddr expr) var)))
                  (list '* (caddr expr) (caddr expr))))
        ;;; sin(u)' = cos(u) * u'
        ((equal (car expr) 'sin)
         (list '* (list 'cos (cadr expr))
                  (deriv (cadr expr) var)))
        ;;; cos(u)' = 0 - sin(u) * u'
        ((equal (car expr) 'cos)
         (list '- 0 (list '* (list 'sin (cadr expr))
                             (deriv (cadr expr) var))))
        ;;; exp(u)' = exp(u) * u'
        ((equal (car expr) 'exp)
         (list '* (list 'exp (cadr expr))
                  (deriv (cadr expr) var)))
        ;;; ln(u)' = u'/u
        ((equal (car expr) 'log)
         (list '/ (deriv (cadr expr) var)
                  (cadr expr)))
       (t (list 'deriv expr var))))

(defun fullsimp(expr)
  (if (equal expr (simp expr))
      expr
      (fullsimp (simp expr))))

(defun evalat(expr var val)
  (setq expr (fullsimp (sublis (list (cons var val)) expr)))
  (eval expr))

(defun nthderiv(expr var n)
  (if (= n 1)
    (deriv expr var)
  	(nthderiv (deriv expr var) var (- n 1))))

(defun !(n)
  "Factorial of natural number n."
  (assert (and (integerp n)
               (or (zerop n) (plusp n)))
          (n)
          "Factorial is not defined for ~S." n)
  (if (= n 0)
    1
    (* n (! (- n 1)))))

(defun taylorcoeff (expr var at n)
  (/ (evalat (nthderiv expr var n) var at)) (! n))

(defun taylorseries (expr var at n)
  (let ((coeffs '()))
    (dotimes (i n (reverse coeffs))
        (setf coeffs (cons (taylorcoeff expr var at i) coeffs)))))


(write (deriv 1 'x))
(write-line "")
(write (simp (deriv 1 'x)))
(write-line "")
(write-line "")
(write (deriv 'x 'x))
(write-line "")
(write (simp (deriv 'x 'x)))
(write-line "")
(write-line "")
(write (deriv 'x 'y))
(write-line "")
(write (simp (deriv 'x 'y)))
(write-line "")
(write-line "")
(write (deriv '(* x x) 'x))
(write-line "")
(write (simp (deriv '(* x x) 'x)))
(write-line "")
(write-line "")
(write (deriv '(/ 1 x) 'x))
(write-line "")
(write (simp (deriv '(/ 1 x) 'x)))
(write-line "")
(write-line "")
(write (deriv '(cos x) 'x))
(write-line "")
(write (simp (deriv '(cos x) 'x)))
(write-line "")
(write-line "")
(write (deriv '(sin (* x x)) 'x))
(write-line "")
(write (simp (deriv '(sin (* x x)) 'x)))
(write-line "")
(write-line "")
(write (deriv '(sin (exp (sin (exp x)))) 'x))
(write-line "")
(write (simp (deriv '(sin (exp (sin (exp x)))) 'x)))
(write-line "")
(write-line "")
(write (deriv '(log x) 'x))
(write-line "")
(write (simp (deriv '(log x) 'x)))
(write-line "")
(write-line "")
(write (deriv '(sin (tan x)) 'x))
(write-line "")
(write (simp (deriv '(sin (tan x)) 'x)))
(write-line "")
(write-line "")
(write (nthderiv '(* x x) 'x 2))
(write-line "")
(write (fullsimp (nthderiv '(* x x) 'x 2)))
(write-line "")
(write-line "")
(write (evalat '(+ x (* x x)) 'X 2))
(write-line "")
(write-line "")
;;(write (taylorseries '(log x) 'x 1 10))
(write-line "")
;;(write (taylorseries '(exp x) 'x 0 10))
(write-line "")
(write (taylorseries '(sin x) 'x 0 10))
(write-line "")
;;(write (taylorseries '(cos x) 'x 0 10))